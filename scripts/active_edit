#!/usr/bin/env python3

# Author: Jamie Strandboge <jamie@ubuntu.com>
# Author: Kees Cook <kees@ubuntu.com>
# Copyright (C) 2005-2016 Canonical Ltd.
#
# This script is distributed under the terms and conditions of the GNU General
# Public License, Version 2 or later. See http://www.gnu.org/copyleft/gpl.html
# for details.

import datetime
import optparse
import os
import pathlib
import re
import sys
import urllib.request

import cve_lib
import source_map

releases = ['upstream'] + cve_lib.all_releases

max_file_size = 10 * 1024 * 1024  # 10MB
cvedir = cve_lib.active_dir

parser = optparse.OptionParser()
parser.add_option("-p", "--package", dest="pkgs", help="Package name and optional version where package is fixed (with optional Ubuntu release and version in that release)", metavar="NAME[,VERSION[,RELEASE,RELEASE_VERSION]]", action="append")
parser.add_option("-b", "--bug-url", dest="bug_urls", help="Bug references", metavar="URL", action="append")
parser.add_option("-r", "--reference-url", dest="ref_urls", help="URL references", metavar="URL", action="append")
parser.add_option("-k", "--kernel-break-fix", dest="breakfix", help="Automatically fetch kernel break-fix data", action="store_true")
parser.add_option("-c", "--cve", dest="cve", help="CVE entry", metavar="CVE-YYYY-NNNN")
parser.add_option("-e", "--embargoed", dest="embargoed", help="This is an embargoed entry", action="store_true")
parser.add_option("-y", "--yes", dest="autoconfirm", help="Do not ask for confirmation", action="store_true")
parser.add_option("-P", "--public", dest="public_date", help="Record date the CVE went public (default to today in UTC)", metavar="YYYY-MM-DD")
parser.add_option("--priority", help="Record a priority for the CVE", default=None)
parser.add_option("-C", "--cvss", help="CVSS3.1 rating", metavar="CVSS:3.1/AV:_/AC:_/PR:_/UI:_/S:_/C:_/I:_/A:_")
parser.add_option("-d", "--description", help="Description", default=None)
(options, args) = parser.parse_args()


source_releases = []
for release in cve_lib.all_releases:
    if cve_lib.is_active_esm_release(release) or cve_lib.is_active_release(release):
        source_releases.append(release)
source = source_map.load(releases=source_releases, skip_eol_releases=False)

added_rel_pkg = []

def pkg_in_rel(pkg,rel):
    if rel in ['upstream']:
        return True
    if rel not in source:
        return False
    return (pkg in source[rel])

def get_releases(pkgname):
    # deep copy
    tmp = []
    for r in releases:
        tmp.append(r)

    # Handle when devel isn't open yet
    if cve_lib.devel_release == '':
        tmp.append('')

    return tmp

def release_wants_dne(release):
    '''Return true if the release wants to have DNE entries in CVE files.'''
    # for now only UBUNTU products should have DNE entries
    _, product, _, _ = cve_lib.get_subproject_details(release)
    return product != None and product == cve_lib.PRODUCT_UBUNTU

def fetch_kernel_fixes(url):
    '''Downloads a kernel commit and returns a list of break-fixes'''
    commit_hash = None
    fixes = []

    # Strip off comment at the end
    if ' ' in url:
        url = url.split(' ')[0]

    # Short URL, turn it into long one
    if url.startswith('https://git.kernel.org/linus/'):
        url = url.replace('https://git.kernel.org/linus/',
                          'https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=')
    if url.startswith('https://git.kernel.org/stable/c/'):
        url = url.replace('https://git.kernel.org/stable/c/',
                          'https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=')

    # Get the raw patch
    url = url.replace('/commit/', '/patch/')

    with urllib.request.urlopen(url) as response:
       patch = response.read().decode('utf-8')

    for line in patch.split("\n"):
        if re.match("commit [0-9a-f]{40} upstream.", line):
            # This is an LTS backport, skip it
            return []
        if not commit_hash and line.startswith("From "):
            commit_hash = line.split(' ')[1]
            continue
        elif line.startswith("Fixes: "):
            fix_hash = line.split(' ')[1]
            fixes.append([fix_hash, commit_hash])

    # If we didn't find a Fixes tag, just use -
    if fixes == []:
        fixes.append(['-', commit_hash])

    return fixes

def in_break_fixes(commit, break_fixes):
    '''See if a commit is in the hash_list'''
    # properly handle comparing short and long hashes
    for [break_hash,fix_hash] in break_fixes:
        if commit.startswith(break_hash):
            return True
        if break_hash.startswith(commit):
            return True
    return False

def validate_kernel_fixes(break_fixes):
    '''Validate list of break-fixes'''

    if break_fixes == []:
        return []

    # Make sure a breaks URL wasn't listed in the URLs by mistake
    validated = []
    for [break_hash,fix_hash] in break_fixes:
        # Don't check this for now, it can result in false positives
        #if not in_break_fixes(fix_hash, break_fixes):
        if True:
            # Make sure it's not a dupe
            dupe = False
            for [v_break_hash,v_fix_hash] in validated:
                if break_hash == v_break_hash and fix_hash == v_fix_hash:
                    dupe = True
            if not dupe:
                validated.append([break_hash, fix_hash])

    return validated

def _add_pkg(p, fp, fixed, parent, embargoed, break_fixes):
    print('', file=fp)
    print('Patches_%s:' % p, file=fp)
    if p == "linux":
        for [url,commit_hash] in break_fixes:
            print(" break-fix: %s %s" % (url, commit_hash), file=fp)
    if p in cve_lib.package_db \
       and "tags" in cve_lib.package_db[p] \
       and p in cve_lib.package_db[p]["tags"] \
       and len(cve_lib.package_db[p]["tags"][p]) > 0:
        print('Tags_%s: %s' % (p, " ".join(cve_lib.package_db[p]["tags"][p])), file=fp)
    # find which releases p exists in
    higher_not_affected = False
    fixed_in = None
    fixed_in_release = None
    fixed_in_release_version = None
    if p in fixed and len(fixed[p]) > 0:
        fixed_in = fixed[p][0]
        if len(fixed[p]) > 1:
            fixed_in_release = fixed[p][1]
        if len(fixed[p]) > 2:
            fixed_in_release_version = fixed[p][2]
    for rel in ['upstream'] + cve_lib.release_sort(list(source.keys())):
        aliases = source_map.get_aliases_of_ubuntu_package(source, p, rel)
        # determine default state but override this if pkg_db has a
        # better one
        state = "needs-triage"
        if not pkg_in_rel(p, rel) and not aliases:
            # package doesn't exist in this release - see if it wants a
            # DNE entry
            if release_wants_dne(rel):
                state = "DNE"
            else:
                continue
        if rel == cve_lib.devel_release:
            # devel is present in source.keys() so continue so we use that
            # instead of the codename
            continue
        elif rel in cve_lib.eol_releases and not cve_lib.is_active_esm_release(rel):
            continue
        elif state != "DNE" and cve_lib.is_active_esm_release(rel):
            state = cve_lib.EOL_ESM_STATUS.split(',')[0] + ')'
        elif rel == 'upstream' and fixed_in is not None:
            state = "released (%s)" % fixed_in
        elif fixed_in_release_version and rel == fixed_in_release:
            state = "not-affected (%s)" % fixed_in_release_version
            higher_not_affected = True
        elif higher_not_affected:
            state = "not-affected"

        # use pkg_db state if one exists
        state_tuple = None
        if p in pkg_db and p in pkg_db[p]["pkgs"] and rel in pkg_db[p]["pkgs"][p]:
            state_tuple = pkg_db[p]["pkgs"][p][rel]
        elif parent is not None and rel in pkg_db[parent]["pkgs"][p]:
            state_tuple = pkg_db[parent]["pkgs"][p][rel]
        if state_tuple:
            state = state_tuple[0]
            if len(state_tuple[1]) > 0:
                state = state + " (%s)" % state_tuple[1]
        if rel not in cve_lib.external_releases:
            print('%s_%s: %s' % (rel, p, state), file=fp)
        # TODO: figure out how to store subproject details for embargoed CVEs
        elif not embargoed:
            pkgs_to_add = [p]
            if aliases:
                pkgs_to_add = aliases

            # If the subproject doesn't require cve triage,
            # we shouldn't add any entries to the CVE
            if not cve_lib.is_cve_triage_required(rel): continue

            for pkg in pkgs_to_add:
                rel_pkgname = rel + '/' + pkg
                if not rel_pkgname in added_rel_pkg:
                    with open(os.path.join(cve_lib.get_external_subproject_cve_dir(rel), cve), "a") as f:
                        print('%s_%s: %s' % (rel, pkg, state), file=f)
                    added_rel_pkg.append(rel_pkgname)

def add_pkg(p, fp, fixed, parent, embargoed, break_fixes):
    # skip packages which don't actually exist in any release
    add = False
    for r in source.keys():
        aliases = source_map.get_all_aliases(source, r)
        add |= p in source[r] or p in aliases
    if add:
        _add_pkg(p, fp, fixed, parent, embargoed, break_fixes)

    # add pkgs from pkgdb but only if we are not already a subpackage
    if parent is None and p in pkg_db:
        for pkg in pkg_db[p]["pkgs"]:
            # don't add the same package twice
            if pkg != p:
                # we don't have fixed data for these subpackages
                add_pkg(pkg, fp, fixed={}, parent=p, embargoed=embargoed, break_fixes=break_fixes)

def create_or_update_cve(cve, packages, priority=None, bug_urls=None,
                         ref_urls=None, public_date=None, desc=None,
                         cvss=None, embargoed=False, breakfix=False):

    pkgs = []
    break_fixes = []
    fixed = {}
    # parse optional fixed_in release and version from package name
    for p in packages:
        tmp_p = p.split(',')
        pkg = tmp_p[0]
        pkgs.append(pkg)
        fixed[pkg] = tmp_p[1:]

    update = False
    try:
        dst = cve_lib.find_cve(cve)
        update = True
    except ValueError:
        dst = os.path.join(pathlib.Path().parent.resolve(),
                           cve_lib.active_dir if not embargoed else cve_lib.embargoed_dir,
                           cve)

    # Download kernel break-fixes
    if breakfix and ref_urls:
        for url in ref_urls:
            if (url.startswith('https://git.kernel.org/linus/') or
                url.startswith('https://git.kernel.org/stable/c/') or
                url.startswith('https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=') or
                url.startswith('https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=')):
                break_fixes += fetch_kernel_fixes(url)
        break_fixes = validate_kernel_fixes(break_fixes)

    # collect notes from pkg_db and add any extra pkgs from pkg_db as well
    notes = []
    for p in pkgs:
        if p in pkg_db:
            notes = notes + pkg_db[p]["notes"]

    # ensure we only add each package once - say if there is openjdk,
    # openjdk-11, openjdk-13 in packages, then they should all reference the
    # same openjdk entry in package-db and so we only need to add this once
    names = set()
    for p in pkgs:
        if p in pkg_db:
            names.add(pkg_db[p]["name"])
        else:
            names.add(p)

    # normalise the list of packages
    pkgs = sorted(list(set(names)))

    # Set a default public date only when the CVE isn't being added to the
    # embargoed tree
    if not embargoed and not public_date:
        public_date = datetime.datetime.utcnow().strftime("%Y-%m-%d")

    if update:
        mode = "a"
    else:
        mode = "x"
    with open(dst, mode, encoding="utf-8") as fp:
        if not update:
            print('Candidate: %s' % (cve), file=fp)
            print('PublicDate: %s' % (public_date if public_date else "unknown"), file=fp)
            if embargoed:
                print('CRD: %s' % (public_date if public_date else "unknown"), file=fp)
            print('References:\n https://cve.mitre.org/cgi-bin/cvename.cgi?name=%s' % (cve), file=fp)
            for url in (ref_urls if ref_urls else []):
                print(" %s" % url, file=fp)
            print('Description:', file=fp)
            for desc_line in (cve_lib.wrap_text(desc).split('\n') if desc else []):
                print(" %s" % (desc_line), file=fp)
            print('Ubuntu-Description:', file=fp)
            print('Notes:', file=fp)
            for note in notes:
                for note_line in cve_lib.wrap_text(note[1], 75 - len(note[0]) - 2).split('\n'):
                    print(" %s> %s" % (note[0], note_line), file=fp)
            print('Mitigation:', file=fp)
            print('Bugs:', file=fp)
            for url in (bug_urls if bug_urls else []):
                print(" %s" % url, file=fp)
            priority_text = priority if priority else "untriaged"
            if priority in cve_lib.PRIORITY_REASON_REQUIRED:
                priority_text += "\n XXX-Reason-XXX"
            print('Priority: %s' % priority_text, file=fp)
            print('Discovered-by:', file=fp)
            print('Assigned-to:', file=fp)
            print('CVSS:', file=fp)
            for entry in (cvss if cvss else []):
                src, cvss = entry
                print(' %s: %s' % (src, cvss), file=fp)

        for p in pkgs:
            add_pkg(p, fp, fixed, None, embargoed, break_fixes)



pkg_db = cve_lib.load_package_db()

if not options.pkgs:
    parser.print_help()
    sys.exit(1)

if not options.cve:
    parser.print_help()
    sys.exit(1)

cve = options.cve
pkgs = options.pkgs
pat = cve_lib.CVE_RE

if options.embargoed:
    cvedir = cve_lib.embargoed_dir
    pat = re.compile(r'^[\w-]*$')

    if not os.path.islink(cvedir):
        print("embargoed/ is not a symlink. Aborting!\n", file=sys.stderr)
        sys.exit(1)


if not pat.search(cve):
    if options.embargoed:
        print("Bad embargoed entry.  Should be alphanumerics and dashes\n", file=sys.stderr)
    else:
        print("Bad CVE entry.  Should be CVE-XXXX-XXXX\n", file=sys.stderr)
    sys.exit(1)

create_or_update_cve(cve, pkgs, priority=options.priority, bug_urls=options.bug_urls, ref_urls=options.ref_urls, public_date=options.public_date, desc=options.description, cvss=options.cvss, embargoed=options.embargoed, breakfix=options.breakfix)
sys.exit(0)
