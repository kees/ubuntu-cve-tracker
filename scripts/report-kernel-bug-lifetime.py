#!/usr/bin/env python

# Author: Kees Cook <keescook@chromium.org>
# Copyright (C) 2015-2023 Google
#
# This script is distributed under the terms and conditions of the GNU General
# Public License, Version 3 or later. See http://www.gnu.org/copyleft/gpl.html
# for details.
#
# Reports the age of kernel CVE fixes.

import os, glob
import re
import sys
import optparse
import cve_lib, usn_lib
import pickle
import datetime
from subprocess import *

def get_comma_separated_args(option, opt, value, parser):
    setattr(parser.values, option.dest, value.split(','))

parser = optparse.OptionParser()
parser.add_option("-d", "--debug", help="Report additional debugging while processing USNs", action='store_true')
parser.add_option("-v", "--verbose", help="Report verbosely", action='store_true')
parser.add_option("-C", "--csv", help="Report as CSV file", action='store_true')
parser.add_option("--priority", help="Priorities to report (comma separated)", action='callback', type='string', default=None, callback=get_comma_separated_args)
(opt, args) = parser.parse_args()

devnull = open("/dev/null", "w")

kerncachefile = os.path.expanduser("~/.cache/kernel-versions.pickle")
if os.path.exists(kerncachefile):
    kerncache = pickle.load(open(kerncachefile, 'rb'))
    try:
        del kerncache['HEAD']
    except:
        pass
else:
    kerncache = dict()
datecache = dict()

# Ignored CVEs (these will always be ignored no matter what happens to fixes)
invalid_cves = [
    # Only exploitable in stable kernels
    'CVE-2016-10229',

    ### Hardware bug mitigations, not kernel bug fixes!
    # Spectre/Meltdown https://wiki.ubuntu.com/SecurityTeam/KnowledgeBase/SpectreAndMeltdown
    'CVE-2017-5715',
    'CVE-2017-5753',
    'CVE-2017-5754',
    # SSB https://wiki.ubuntu.com/SecurityTeam/KnowledgeBase/Variant4
    'CVE-2018-3639',
    # BCBS https://wiki.ubuntu.com/SecurityTeam/KnowledgeBase/BCBS
    'CVE-2018-3693',
    # L1TF https://wiki.ubuntu.com/SecurityTeam/KnowledgeBase/L1TF
    'CVE-2018-3620',
    'CVE-2018-3646',
    # MDS https://wiki.ubuntu.com/SecurityTeam/KnowledgeBase/MDS
    'CVE-2018-12126',
    'CVE-2018-12127',
    'CVE-2018-12130',
    'CVE-2019-11091',
]

# Kernel CVEs confirmed to not be in upstream that have non-upstream
# fixes (i.e. if an ACTUAL upstream fix is discovered, these will get
# included in ouput again).
not_upstream = [
    'CVE-2011-1768',
    'CVE-2013-1060',
    # Not a real security vulnerability: already fully initialized to zero.
    'CVE-2014-9900',
    'CVE-2015-3332',
    'CVE-2015-7312',
    'CVE-2015-7837',
    'CVE-2015-8019',

# overlayfs nosuid, unfixed, but may be only Ubuntu? (2018-01-22)
# Mitre claims this merge fixes it: https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=e9f57ebcba563e0cd532926cab83c92bb4d79360
# CVE-2016-1575: Claiming local fix as unfixed upstream (local-2016-1575-2)
# CVE-2016-1576: Claiming local fix as unfixed upstream (local-2016-1576-1)
# CVE-2016-1576: Claiming local fix as unfixed upstream (local-2016-1576-2)

    # Lockdown series.
    'CVE-2016-3695',
    'CVE-2018-18653',

    # Not actually a bug.
    'CVE-2019-11191',

    # Fixed in the same release as bug was introduced.
    'CVE-2008-3534',
    'CVE-2011-2184',
    'CVE-2011-2393',
    'CVE-2011-2521',
    'CVE-2011-3637',
    'CVE-2012-3510',
    'CVE-2013-3236',
    'CVE-2013-3237',
    'CVE-2013-4129',
    'CVE-2013-7348',
    'CVE-2014-9717',
    'CVE-2014-9903',
    'CVE-2015-4176',
    'CVE-2015-4177',
    'CVE-2015-4178',
    'CVE-2016-2550',
    'CVE-2016-6162',
    'CVE-2016-9919',
    'CVE-2017-13686',
    'CVE-2017-18200',
    'CVE-2017-7979',
    'CVE-2017-8065',
    'CVE-2018-1000028',
    'CVE-2018-10074',
    'CVE-2018-14641',
]

# For Critical and High, I want to double-check all the missing "breaks".
# These are the ones I've manually checked to be "pre git history" to my
# satisfaction.
verified_breaks = [
    'CVE-2013-0871',
    'CVE-2014-0205',
    'CVE-2014-1737',
    'CVE-2014-1738',
    'CVE-2014-3917',
    'CVE-2014-8159',
    'CVE-2014-9322',
    'CVE-2015-3290',
    'CVE-2015-7613',
    'CVE-2016-3841',
    'CVE-2016-3134',
    'CVE-2017-7308',
    'CVE-2017-1000379',
    'CVE-2018-7755',
    'CVE-2018-8897',
    'CVE-2019-11478',
]
needs_verified_breaks = [
]

def _extract_sha(sha):
    if '/' in sha:
        sha = sha.split('/')[-1]
    if '=' in sha:
        sha = sha.split('=')[-1]
    return sha.strip()

def get_release(name, sha):
    if sha in kerncache and kerncache[sha] != "":
        return kerncache[sha]
    output = Popen(["git", "contains", sha], stdout=PIPE, stderr=devnull).communicate()[0].decode("utf-8")
    release = output.strip()
    if '-' in release:
        release = release.split('-')[0]
    if sha != 'HEAD' and not '-NEWER' in output:
        kerncache[sha] = release
        pickle.dump(kerncache, open(kerncachefile, 'wb'), -1)
    if release == "":
        print("Whoops: %s %s missing a release?" % (name, sha), file=sys.stderr)
    return release

def get_sha_date(sha):
    if sha in datecache:
        return datecache[sha]
    output = Popen(["git", "show", "--pretty=%at", "-s", "%s^{commit}" % (sha)],
                   stdout=PIPE, stderr=devnull).communicate()[0].decode("utf-8")
    try:
        date = datetime.datetime.fromtimestamp(float(output.strip()))
    except:
        # Stuff that hasn't been released yet.
        date = datetime.datetime.now()
    datecache[sha] = date
    return date

# Find all CVE paths
cvelist = []
cves = dict()
active = set()
check_dirs = [cve_lib.active_dir, cve_lib.retired_dir, cve_lib.ignored_dir]
for dirname in check_dirs:
    if len(args)==0:
        items = glob.glob('%s/CVE-*' % (dirname))
    else:
        items = [y for y in ['%s/%s' % (dirname, x) for x in args] if os.path.exists(y)]
    items = sorted(items)
    for cvefile in items:
        cvelist += [cvefile]

# Load and keep only kernel CVEs
if opt.debug:
    print("Finding kernel CVEs ...", file=sys.stderr)
for cvefile in cvelist:
    #if opt.debug:
    #    print("\treading %s ..." % (cvefile), file=sys.stderr)
    state, cve = cvefile.split('/')[-2:]
    info = cve_lib.load_cve(cvefile)
    if 'linux' in info['patches']:
        # Skip stuff that isn't in upstream.
        if 'not-affected' in info['pkgs']['linux']['upstream']:
            continue
        # Skip known invalid CVEs.
        if cve in invalid_cves:
            continue
        ### Adjust priority where I disagree with Ubuntu Security Team... ;)
        # DirtyCOW
        if cve == 'CVE-2016-5195':
            info['Priority'][0] = 'critical'
        if opt.priority and not info['Priority'][0] in opt.priority:
            continue
        cves[cve] = info
        active.add(cve)
        #if opt.debug:
        #    print("\t\tkeeping", file=sys.stderr)

os.chdir("../src/linux")

if opt.debug:
    print("Processing CVEs ...", file=sys.stderr)
for cve in cves:
    #if opt.debug:
    #    print("\tchecking %s ..." % (cve), file=sys.stderr)
    shas = []
    for field, value in cves[cve]['patches']['linux']:
        if field != "break-fix":
            continue
        value = value.strip()
        broken = None
        sha = None
        if ' ' in value:
            broken, sha = [_extract_sha(x) for x in value.split(' ',1)]
        if broken and broken == "-":
            broken = "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
        if not sha or sha == "-":
            sha = "HEAD"
        if sha and sha != "-":
            shas.append((broken, sha))
    if cves[cve]['pkgs']['linux']['upstream'] != "needed" and \
       len(shas) == 0:
        continue
    # Manually mark up CVE-2016-1575/-1576 because it's very weird...
    # Maybe the priority should be lowered instead?
    if cve in ['CVE-2016-1575', 'CVE-2016-1576']:
        shas = []
        shas.append(('e9be9d5e76e34872f0c37d72e25bc27fe9e2c54c',
                     'e9f57ebcba563e0cd532926cab83c92bb4d79360'))

    if opt.verbose:
        print("%s %s" % (cve, cves[cve]['Priority'][0]))
    # State tracking
    before_git = False
    unfixed = False
    # Date tracking
    flaw_oldest = None
    fix_oldest = None
    fix_newest = None
    cve_oldest = None
    # Release tracking
    flaw_oldest_rel = None
    fix_oldest_rel = None
    fix_newest_rel = None

    # Figure out when the earliest time the CVE was public.
    try:
        cve_oldest = datetime.date(*[int(x) for x in cves[cve]['PublicDateAtUSN'].split(' ')[0].split('-')])
    except:
        pass
    date = datetime.date(*[int(x) for x in cves[cve]['PublicDate'].split(' ')[0].split('-')])
    if cve_oldest == None or date < cve_oldest:
        cve_oldest = date
    if opt.verbose:
        print("\tCVE date: %s" % (cve_oldest))

    # Process each sha listed as related to the bug.
    flaw_seen = set()
    flaw_verbose = []
    fix_seen = set()
    fix_verbose = []
    for item in shas:
        flaw_sha = item[0]
        fix_sha = item[1]

        if flaw_sha == '1da177e4c3f41524e886b7f1b8a0c1fc7321cac2' and \
           cves[cve]['Priority'][0] in ['critical', 'high'] and \
           cve not in verified_breaks and \
           cve not in needs_verified_breaks:
            print("%s: Verify start-of-git-history 'breaks'" % (cve), file=sys.stderr)
            needs_verified_breaks.append(cve)

        # Handle the "local|$realSHA" syntax, taking first non-local fix
        if fix_sha and "|" in fix_sha:
            possible = fix_sha.split("|")
            for check in possible:
                if "local" in check:
                    continue
                fix_sha = check
                break

        if fix_sha and fix_sha.startswith("local-"):
            if cve in not_upstream:
                continue
            print("%s: Claiming local fix as unfixed upstream (%s)" % (cve, fix_sha), file=sys.stderr)
            fix_sha = "HEAD"

        if flaw_sha and flaw_sha.startswith("local-"):
            if cve in not_upstream:
                print("%s: Ignoring unreleased flaw (%s)" % (cve, flaw_sha), file=sys.stderr)
            continue

        flaw_rel = get_release("flaw", flaw_sha)
        if flaw_rel == "" and not cve in not_upstream:
            print("%s: Ignoring unknown flaw (%s)" % (cve, flaw_sha), file=sys.stderr)
            continue

        flaw_date = get_sha_date(flaw_rel)
        if flaw_oldest == None or flaw_date < flaw_oldest:
            flaw_oldest = flaw_date
            flaw_oldest_rel = flaw_rel

        fix_rel = get_release("fix", fix_sha)
        fix_date = get_sha_date(fix_rel)
        if fix_newest == None or fix_date > fix_newest:
            fix_newest = fix_date
            fix_newest_rel = fix_rel
        if fix_oldest == None or fix_date < fix_oldest:
            fix_oldest = fix_date
            fix_oldest_rel = fix_rel

        if flaw_sha == "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2":
            before_git = True
        if fix_sha == "HEAD" and not opt.csv:
            unfixed = True

        if opt.verbose:
            if not flaw_sha in flaw_seen:
                flaw_verbose.append("\tFlaw: %s (%s %s)" % (flaw_sha, flaw_date.date(), flaw_rel))
            if not unfixed and not fix_sha in fix_seen:
                fix_verbose.append("\tFix:  %s (%s %s)" % (fix_sha, fix_date.date(), fix_rel))
        flaw_seen.add(flaw_sha)
        fix_seen.add(fix_sha)

    if fix_newest == None and flaw_oldest == None:
        if not cve in not_upstream:
            print("%s: Ignored (no upstream flaws)" % (cve), file=sys.stderr)
        continue

    if fix_newest == flaw_oldest:
        if not cve in not_upstream:
            print("%s: Ignored (discovered and fixed in same release)" % (cve), file=sys.stderr)
        continue

    if opt.verbose:
        print("\n".join(flaw_verbose))
        if not unfixed:
            print("\n".join(fix_verbose))

        if unfixed:
            print("\tTotal Flaw Liftime: UNFIXED")
        elif before_git:
            print("\tTotal Flaw Lifetime: >%d" % (fix_newest - flaw_oldest).days)
        else:
            print("\tTotal Flaw Lifetime: %d" % (fix_newest - flaw_oldest).days)
        if unfixed:
            print("\tFix to CVE: UNFIXED")
        else:
            print("\tFix to CVE: %d" % (fix_oldest.date() - cve_oldest).days)
    else:
        report = "%s %s " % (cve, cves[cve]['Priority'][0])
        if unfixed:
            report += "UNFIXED"
        else:
            if before_git:
                report += ">%d" % (fix_newest - flaw_oldest).days
            else:
                report += "%d" % (fix_newest - flaw_oldest).days
            report += " %s %s %s %s" % (flaw_oldest_rel, flaw_oldest.date(),
                                        fix_newest_rel, fix_newest.date())
            report += " %d" % (fix_oldest.date() - cve_oldest).days
        if opt.csv:
            report = report.replace(' ', ',')
            report = report.replace('>', '')
        print(report)
