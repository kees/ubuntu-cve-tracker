#!/usr/bin/env python3

import lpl_common
import sys
from debian import debian_support
import os
import re
import pickle
import argparse

# cve_lib may not be in PYTHONPATH so try harder to find it
try:
    import cve_lib
except ImportError:
    uct_path = os.getenv('UCT')
    if uct_path is not None:
        sys.path.append(os.path.join(uct_path, 'scripts'))
        import cve_lib

def get_ppa_list():
    ppa_list = {}
    lp = lpl_common.connect()
    distribution = lp.distributions['ubuntu']
    ubuntu = lp.distributions['ubuntu']
    for ppa in ["infra", "apps"]:
        ppa_list[ppa] = {}
        for release in lts_releases:
            ppa_list[ppa][release] = {}
            series = ubuntu.getSeries(name_or_version = release)
            ppa_full_name = "ubuntu-esm/esm-%s-security" % ppa
            archive, group, ppa_full_name = lpl_common.get_archive(ppa_full_name,
                    lp, False, distribution = distribution)
            for src in archive.getPublishedSources(status = 'Published', distro_series = series):
                ppa_list[ppa][release][src.source_package_name] = src.source_package_version
    return ppa_list

def get_uct_list():
    (cves, uems, rcves) = cve_lib.get_cve_list_and_retired()
    uct_list = dict()
    for cve in cves:
        cve_data = cve_lib.load_cve(cve_lib.find_cve(cve))
        for package, releases in cve_data['pkgs'].items():
            for release, status in releases.items():
                version = status[1]
                if not re.search(esm_regex, version):
                    continue
                if package not in uct_list:
                    uct_list[package] = dict()

                if release in uct_list[package]:
                    # print("%s: %s > %s" % (package, version, uct_list[package][release]))
                    if debian_support.version_compare(version,
                            uct_list[package][release]):
                        uct_list[package][release] = version
                else:
                    uct_list[package][release] = version
    return uct_list

def get_list(ppa_uct):
    return get_ppa_list() if ppa_uct == "ppa" else get_uct_list()

esm_regex = "esm[0-9]+$"
lts_releases = []
for release in cve_lib.all_releases:
    if (release in cve_lib.releases and release not in cve_lib.eol_releases) \
            or cve_lib.is_active_esm_release(release):
        lts_releases.append(release)
src_list = {}

parser = argparse.ArgumentParser()
parser.add_argument('--cache', action='store_true')
args = parser.parse_args()

for item in ["ppa", "uct"]:
    pickle_file = f"list_{item}.pickle"
    src_list[item] = pickle.load(open(pickle_file, "rb")) \
            if args.cache and os.path.exists(pickle_file) else get_list(item)
    if args.cache:
        pickle.dump(src_list[item], open(pickle_file, "wb"))

for ppa in ["infra", "apps"]:
    for release in lts_releases:
        for source in src_list["ppa"][ppa][release]:
            ppa_version = src_list["ppa"][ppa][release][source]
            if source == "hello" or not re.search(esm_regex, ppa_version):
                continue
            rel = "trusty/esm" if release == "trusty" else f"esm-{ppa}/{release}"
            if source in src_list["uct"] and rel in src_list["uct"][source]:
                uct_version = src_list["uct"][source][rel]
                if ppa_version != uct_version:
                    print(f"{ppa}: {source} for {release}, {ppa_version} (PPA) != {uct_version} (UCT)!")
                continue
            print(f"{ppa}: {source} for {release}, any version, not found in UCT!")
