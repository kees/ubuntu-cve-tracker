#!/usr/bin/env python3

# Author: Alex Murray <alex.murray@canonical.com>
# Copyright (C) 2021 Canonical Ltd.
#
# This script is distributed under the terms and conditions of the GNU General
# Public License, Version 2 or later. See http://www.gnu.org/copyleft/gpl.html
# for details.

import argparse
import os
import sys
import cve_lib


def insert_into_file(filename: str, linenum: int, line: str, dryrun=False):
    """Insert line into filename at linenum."""
    if not dryrun:
        # file may not already exist
        contents = []
        try:
            with open(filename, "r") as f:
                contents = f.readlines()
        except FileNotFoundError:
            pass
        # linenum is 1 based but arrays are 0-based
        contents.insert(linenum - 1, line)
        with open(cve, "w") as f:
            f.write("".join(contents))
    else:
        print("%s: %d: would insert '%s'" % (os.path.relpath(filename), linenum, line))


def delete_from_file(filename: str, linenum: int, dryrun=False):
    """Delete line at linenum from filename."""
    if not dryrun:
        # file may not already exist
        contents = []
        try:
            with open(filename, "r") as f:
                contents = f.readlines()
        except FileNotFoundError:
            pass
        # linenum is 1 based but arrays are 0-based
        del contents[linenum - 1]
        with open(cve, "w") as f:
            f.write("".join(contents))
    else:
        print("%s: %d: would delete this line" % (os.path.relpath(filename), linenum))


parser = argparse.ArgumentParser("Automatically fixup issues flagged by check-syntax")
parser.add_argument(
    "-n",
    "--dry-run",
    action="store_true",
    default=False,
    help="Don't perform any actual modifications just print what would be done.",
)
parser.add_argument(
    "infile",
    nargs="?",
    help="File to read input from. Defaults to stdin.",
    type=argparse.FileType("r"),
    default=sys.stdin,
)
args = parser.parse_args()
if args.dry_run:
    print("DRY RUN - LIKE THE MATRIX, THIS IS JUST A SIMULATION.")


for line in args.infile:
    handled = False
    # parse out file name, line number, and message
    parts = line.split(":")
    if len(parts) != 3:
        continue
    # strip whitespace from all parts
    parts = map(lambda s: s.strip(), parts)
    cve, linenum, msg = parts
    linenum = int(linenum)

    if "missing supported release" in msg:
        # e.g. golang missing supported release 'gke/gke-1.19'
        parts = msg.split(" ")
        pkg = parts[0]
        rel = parts[4].replace("'", "")

        if rel in cve_lib.external_releases:
            # ignore boilerplate files for external_releases
            if "boilerplate" in cve:
                # print unhandled lines
                print(line, file=sys.stderr)
                continue
            cve = os.path.join(
                cve_lib.get_external_subproject_cve_dir(rel), os.path.basename(cve)
            )
            # linenum is only relevant to the original cve file
            linenum = 1

        fixup = "{rel}_{pkg}: needs-triage\n".format(rel=rel, pkg=pkg)
        insert_into_file(cve, linenum, fixup, args.dry_run)

    elif "unknown package" in msg or "not in" in msg or "unknown release" in msg:
        # delete this line since
        delete_from_file(cve, linenum, args.dry_run)
    else:
        # print unhandled lines
        print(line, file=sys.stderr)
