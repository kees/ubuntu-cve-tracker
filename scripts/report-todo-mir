#!/usr/bin/env python3
# Copyright 2018-2022 Canonical, Ltd.
# Authors:
#    Alex Murray <alex.murray@canonical.com>
#    Steve Beattie <steve.beattie@canonical.com>
# License: GPLv3
#
# Report MIRs for the security team
#

from __future__ import print_function

import argparse
import re
import sys
from launchpadlib.launchpad import Launchpad
import cve_lib

# by default we want all not in Fix Released, Fix Committed, Opinion, Invalid,
# Won't Fix & Expired which leaves the following
search_status = [
    'New',
    'Incomplete',
    'Confirmed',
    'Triaged',
    'In Progress',
]

# all acceptable LP statuses
all_statuses = search_status + [
    'Fix Released',
    'Fix Committed',
    'Opinion',
    'Invalid',
    "Won't Fix",
]

valid_priorities = [
    'Undecided',
    'Critical',
    'High',
    'Medium',
    'Low',
    'Wishlist',
]

parser = argparse.ArgumentParser()
parser.add_argument("-d", "--debug", help="Verbose processing output", action='count')
parser.add_argument("--team", help="Find bugs for team (default ubuntu-security)", metavar="TEAM", action='store', default='ubuntu-security')
group = parser.add_mutually_exclusive_group()
group.add_argument("--team-only", help="Only report bugs assigned to the team, not to the members of the team", action='store_true')
group.add_argument("--team-members-only", help="Only report bugs assigned to members of the team, not the team itself", action='store_true')
parser.add_argument("--status", help="Specify status for bugs", metavar="STATUS", action='append', choices=all_statuses)
parser.add_argument("--priority", help="Specify priority for bugs", metavar="PRIORITY", action='append', choices=valid_priorities)
parser.add_argument("--last-message-date", help="Sort bugs by their most recent message", action='store_true')
parser.add_argument("--missing-jira-tag", help="Report only bugs that are missing an associated Jira tag", action='store_true')
parser.add_argument("--oneline", help="Compressed output useful for cronjobs ", action='store_true')

args = parser.parse_args()

# caution, can expose credentials
if args.debug and args.debug >= 2:
    import httplib2
    httplib2.debuglevel = 1


def debug(msg):
    '''Print debug message'''
    if args.debug:
        print(f"DEBUG: {msg}", file=sys.stderr)


def sort_by_date_last_message(task):
    return task[1].bug.date_last_message


def sort_by_id(task):
    return task[0]


class MIRTask():
    def __init__(self, task, assignee):
        debug(task.title)
        self.task = task
        self.status = task.status
        self.importance = task.importance
        # cache the bug reference, or else if referred to via task.bug,
        # it will result in another http request to launchpad.
        self.bug = task.bug
        self.bugid = self.bug.id
        self.tags = self.bug.tags
        self.assignee = assignee

        self.cves = []
        tcves = self.bug.cves
        if tcves is not None:
            for c in tcves:
                self.cves.append("CVE-" + c.sequence)

        bug_target_name = task.bug_target_name
        if ' (' not in bug_target_name:
            raise ValueError(f"Skipping target name={bug_target_name} (LP: #{self.bugid})")

        self.pkg, target = bug_target_name.split(' (', 1)
        self.target = target.split(')')[0]
        if ' ' in self.target:
            self.target, self.release = self.target.split(' ', 1)
        else:
            self.release = self.target.lower()

    def print_detail(self, display_last_msg_date=False):
        print(f"=== Source: {self.pkg} ({self.release}) ===")
        print(f" * Status: {self.status}", end=" ")
        if self.status == "Fix Committed":
            print(f"(committed on {str(self.task.date_fix_committed).split(' ', maxsplit=1)[0]})")
        elif self.status == "In Progress":
            print(f"(marked 'In Progress' on {str(self.task.date_in_progress).split(' ', maxsplit=1)[0]})")
        else:
            print("")

        print(f" * Priority: {self.importance}")
        print(f" * Assigned to: {self.assignee.name}")

        if self.tags:
            print(f" * Tags: {' '.join(self.tags)}")

        print(f" * URL: https://launchpad.net/bugs/{self.bugid}")

        if len(self.cves) > 0:
            print(f" * CVES: {' '.join(self.cves)}")

        if display_last_msg_date:
            print(f" * Last message: {self.bug.date_last_message}")

        print("")

    def get_jira_tags(self, prefix="sec"):
        return [t for t in self.tags if t.startswith(prefix.lower() + '-')]

    def print_oneline(self):
        output = f"[{self.bugid}] {self.pkg}"
        if self.release != 'ubuntu':
            output += f"/{self.release}"
        output += f" ({self.status}, {self.importance}, {self.assignee.name}) "
        output += " ".join(self.get_jira_tags('sec'))
        print(output)


class MIRTaskSet():
    def __init__(self):
        self._tasks = {}

    def add(self, task):
        bugid = str(task.bugid) + task.pkg + ":" + task.release
        if task.release != 'ubuntu' or bugid not in self._tasks:
            self._tasks[bugid] = task

    def get_tasklist(self):
        return [t[1] for t in sorted(self._tasks.items(), key=sort_by_id)]

    def get_tasklist_sorted_by_last_message(self):
        return [t[1] for t in sorted(self._tasks.items(), key=sort_by_date_last_message, reverse=True)]


def print_bugs(tasks, args):
    '''Output a collection of bugs'''
    if args.last_message_date:
        tasklist = tasks.get_tasklist_sorted_by_last_message()
    else:
        tasklist = tasks.get_tasklist()

    count = 0
    for mir_bug in tasklist:
        if args.status and mir_bug.status not in args.status:
            debug(f"Skipping LP: #{mir_bug.bugid} ({mir_bug.status} != {args.status})")
            continue
        if args.priority and mir_bug.importance not in args.priority:
            debug(f"Skipping LP: #{mir_bug.bugid} ({mir_bug.bugid} not in {'|'.join(args.priority)})")
            continue
        if mir_bug.target and mir_bug.target.lower() != 'ubuntu':
            debug(f'skipping target "{mir_bug.target}" ({mir_bug.pkg}) (LP: #{mir_bug.bugid})')
            continue
        if mir_bug.status in ['Fix Released', 'Invalid', "Won't Fix"]:
            debug(f'skipping (pkg:{mir_bug.pkg} status:{mir_bug.status} LP: #{mir_bug.bugid})')
            continue
        if args.missing_jira_tag and mir_bug.get_jira_tags('sec') != []:
            debug(f'skipping (pkg:{mir_bug.pkg} LP: #{mir_bug.bugid} tags: {mir_bug.tags})')
            continue
        if not re.match(r'^[a-z0-9][a-z0-9+\.\-]+$', mir_bug.pkg):
            print(f"Bad package name '{mir_bug.pkg}' (LP: #{mir_bug.bugid})", file=sys.stderr)
            continue

        if args.oneline:
            mir_bug.print_oneline()
        else:
            mir_bug.print_detail(args.last_message_date)

        count += 1

    # How many unique bugs did we report on?
    return count


# taskdb: data structure tasks are to be added to
# assignees: list of assignees, include parent team
def lookup_tasks_for_assignees(taskdb, assignees):
    for assignee in assignees:
        task_collection = lp.bugs.searchTasks(
            bug_subscriber=mir_team,
            assignee=assignee,
            omit_targeted=False,
            omit_duplicates=False,
            status=search_status
        )

        for task in task_collection:
            # handle bugs which list multiple packages in the single MIR as
            # separate bugs
            try:
                mir_task = MIRTask(task, assignee)
            except ValueError as e:
                print(e, file=sys.stderr)
                continue

            taskdb.add(mir_task)


# Load configuration
cve_lib.read_config()

# API interface
debug("Connecting to LP ...")
lp = Launchpad.login_anonymously("report-todo-mir", "production", version="devel")

ubuntu = lp.distributions['ubuntu']
debug(f"Distribution: {ubuntu}")
team = lp.people[args.team]
mir_team = lp.people['ubuntu-mir']
debug(f"Team: {team}")

if args.status:
    search_status = args.status

# get team members
if args.team_only:
    all_assignees = [team]
    assigned_debug_desc = f"{team.name}"
else:
    assignees = [member.member for member in team.members_details]
    assignee_names = [assignee.name for assignee in assignees]
    if args.team_members_only:
        all_assignees = assignees
        assigned_debug_desc = f"the members of {team.name}: {', '.join(assignee_names)}"
    else:
        all_assignees = assignees + [team]
        assigned_debug_desc = f"{team.name} and its members: {', '.join(assignee_names)}"

debug("Loading bugs ...")
tasks = MIRTaskSet()

debug(f"Gathering MIR bugs assigned to {assigned_debug_desc}")
lookup_tasks_for_assignees(tasks, all_assignees)

debug(f"Found {len(tasks.get_tasklist())} bugs across all supported releases")

count = print_bugs(tasks, args)

if args.status:
    print(f"{count} bugs found for '{args.team}' with status '{'|'.join(search_status)}'")
else:
    print(f"{count} open bugs found for '{args.team}'")

sys.exit(0)
